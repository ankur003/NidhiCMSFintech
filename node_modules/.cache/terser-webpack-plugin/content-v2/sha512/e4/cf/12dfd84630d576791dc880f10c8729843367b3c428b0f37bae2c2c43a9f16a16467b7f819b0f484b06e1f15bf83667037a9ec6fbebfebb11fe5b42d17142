{"map":"{\"version\":3,\"sources\":[\"/home/ankur/Documents/personal/shekher_react/NidhiCMSFintech/app/utils/constants.js\",\"/home/ankur/Documents/personal/shekher_react/NidhiCMSFintech/app/utils/sagaInjectors.js\",\"/home/ankur/Documents/personal/shekher_react/NidhiCMSFintech/app/utils/injectSaga.js\",\"/home/ankur/Documents/personal/shekher_react/NidhiCMSFintech/app/utils/checkStore.js\",\"/home/ankur/Documents/personal/shekher_react/NidhiCMSFintech/app/utils/reducerInjectors.js\",\"/home/ankur/Documents/personal/shekher_react/NidhiCMSFintech/app/utils/injectReducer.js\"],\"names\":[\"DAEMON\",\"ONCE_TILL_UNMOUNT\",\"allowedModes\",\"checkKey\",\"key\",\"invariant\",\"isString_default\",\"isEmpty_default\",\"checkDescriptor\",\"descriptor\",\"shape\",\"saga\",\"isFunction_default\",\"a\",\"mode\",\"includes\",\"conformsTo_default\",\"injectSagaFactory\",\"store\",\"isValid\",\"arguments\",\"length\",\"undefined\",\"args\",\"checkStore\",\"newDescriptor\",\"_objectSpread\",\"hasSaga\",\"Reflect\",\"has\",\"injectedSagas\",\"task\",\"runSaga\",\"ejectSagaFactory\",\"cancel\",\"getInjectors\",\"injectSaga\",\"ejectSaga\",\"useInjectSaga\",\"_ref2\",\"context\",\"React\",\"useContext\",\"ReactReduxContext\",\"useEffect\",\"injectors\",\"dispatch\",\"lodash_isFunction__WEBPACK_IMPORTED_MODULE_1___default\",\"subscribe\",\"getState\",\"replaceReducer\",\"injectedReducers\",\"lodash_isObject__WEBPACK_IMPORTED_MODULE_0___default\",\"lodash_conformsTo__WEBPACK_IMPORTED_MODULE_2___default\",\"injectReducerFactory\",\"reducer\",\"createReducer\",\"injectReducer\",\"useInjectReducer\"],\"mappings\":\"iaACaA,EAAS,yBACTC,EAAoB,ieCIjC,IAAMC,EAAe,CDNa,qCCMQF,EAAQC,GAE5CE,EAAW,SAAAC,GAAG,OAClBC,GAAAA,CACEC,GAAAA,CAASF,KAASG,GAAAA,CAAQH,GAC1B,uEAGEI,EAAkB,SAAAC,GACtB,IAAMC,EAAQ,CACZC,KAAMC,EAAAC,EACNC,KAAM,SAAAA,GAAI,OAAIR,GAAAA,CAASQ,IAASZ,EAAaa,SAASD,KAExDT,GAAAA,CACEW,GAAAA,CAAWP,EAAYC,GACvB,gEAIG,SAASO,EAAkBC,EAAOC,GACvC,OAAO,SAAoBf,GAA4B,IAAvBK,EAAuBW,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAV,GAAIG,EAAMH,UAAAC,OAAA,EAAAD,UAAA,QAAAE,EAChDH,GAASK,OAAAA,EAAAA,EAAAA,CAAWN,GAEzB,IAAMO,EAAaC,EAAA,GACdjB,EADc,CAEjBK,KAAML,EAAWK,MAAQd,IAEnBW,EAAec,EAAfd,KAAMG,EAASW,EAATX,KAEdX,EAASC,GACTI,EAAgBiB,GAEhB,IAAIE,EAAUC,QAAQC,IAAIX,EAAMY,cAAe1B,KAY5CuB,GACAA,GAAWb,IAASd,GAAUc,IAASb,KAGxCiB,EAAMY,cAAc1B,GAApBsB,EAAA,GACKD,EADL,CAEEM,KAAMb,EAAMc,QAAQrB,EAAMY,OAO3B,SAASU,EAAiBf,EAAOC,GACtC,OAAO,SAAmBf,GAKxB,GAJKe,GAASK,OAAAA,EAAAA,EAAAA,CAAWN,GAEzBf,EAASC,GAELwB,QAAQC,IAAIX,EAAMY,cAAe1B,GAAM,CACzC,IAAMK,EAAaS,EAAMY,cAAc1B,GACnCK,EAAWK,MAAQL,EAAWK,OAASd,IACzCS,EAAWsB,KAAKG,SAIdhB,EAAMY,cAAc1B,GAAO,UAOtB,SAAS+B,EAAajB,GAGnC,OAFAM,OAAAA,EAAAA,EAAAA,CAAWN,GAEJ,CACLkB,WAAYnB,EAAkBC,GAAO,GACrCmB,UAAWJ,EAAiBf,GAAO,oCCtExB,IA8BToB,EAAgB,SAAAC,GAAyB,IAAtBnC,EAAsBmC,EAAtBnC,IAAKO,EAAiB4B,EAAjB5B,KAAMG,EAAWyB,EAAXzB,KAC5B0B,EAAUC,EAAAA,EAAMC,WAAWC,EAAAA,mBACjCF,EAAAA,EAAMG,UAAU,WACd,IAAMC,EAAYV,EAAaK,EAAQtB,OAGvC,OAFA2B,EAAUT,WAAWhC,EAAK,CAAEO,KAAAA,EAAMG,KAAAA,IAE3B,WACL+B,EAAUR,UAAUjC,KAErB,gPCnDU,SAASoB,EAAWN,GACjC,IAAMR,EAAQ,CACZoC,SAAUC,EAAAlC,EACVmC,UAAWD,EAAAlC,EACXoC,SAAUF,EAAAlC,EACVqC,eAAgBH,EAAAlC,EAChBmB,QAASe,EAAAlC,EACTsC,iBAAkBC,EAAAvC,EAClBiB,cAAesB,EAAAvC,GAEjBR,GAAAA,CACEgD,GAAAA,CAAWnC,EAAOR,GAClB,2ZCZG,SAAS4C,EAAqBpC,EAAOC,GAC1C,OAAO,SAAuBf,EAAKmD,GAC5BpC,GAASK,OAAAA,EAAAA,EAAAA,CAAWN,GAEzBb,GAAAA,CACEC,GAAAA,CAASF,KAASG,GAAAA,CAAQH,IAAQQ,GAAAA,CAAW2C,GAC7C,6EAKA3B,QAAQC,IAAIX,EAAMiC,iBAAkB/C,IACpCc,EAAMiC,iBAAiB/C,KAASmD,IAIlCrC,EAAMiC,iBAAiB/C,GAAOmD,EAC9BrC,EAAMgC,eAAeM,OAAAA,EAAAA,EAAAA,CAActC,EAAMiC,qBAI9B,SAAShB,EAAajB,GAGnC,OAFAM,OAAAA,EAAAA,EAAAA,CAAWN,GAEJ,CACLuC,cAAeH,EAAqBpC,GAAO,oCClBhC,IAwBTwC,EAAmB,SAAAnB,GAAsB,IAAnBnC,EAAmBmC,EAAnBnC,IAAKmD,EAAchB,EAAdgB,QACzBf,EAAUC,EAAAA,EAAMC,WAAWC,EAAAA,mBACjCF,EAAAA,EAAMG,UAAU,WACdT,EAAaK,EAAQtB,OAAOuC,cAAcrD,EAAKmD,IAC9C\",\"sourcesContent\":[\"export const RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\\nexport const DAEMON = '@@saga-injector/daemon';\\nexport const ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';\\n\",\"import invariant from 'invariant';\\nimport { isEmpty, isFunction, isString, conformsTo } from 'lodash';\\n\\nimport checkStore from './checkStore';\\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants';\\n\\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\\n\\nconst checkKey = key =>\\n  invariant(\\n    isString(key) && !isEmpty(key),\\n    '(app/utils...) injectSaga: Expected `key` to be a non empty string',\\n  );\\n\\nconst checkDescriptor = descriptor => {\\n  const shape = {\\n    saga: isFunction,\\n    mode: mode => isString(mode) && allowedModes.includes(mode),\\n  };\\n  invariant(\\n    conformsTo(descriptor, shape),\\n    '(app/utils...) injectSaga: Expected a valid saga descriptor',\\n  );\\n};\\n\\nexport function injectSagaFactory(store, isValid) {\\n  return function injectSaga(key, descriptor = {}, args) {\\n    if (!isValid) checkStore(store);\\n\\n    const newDescriptor = {\\n      ...descriptor,\\n      mode: descriptor.mode || DAEMON,\\n    };\\n    const { saga, mode } = newDescriptor;\\n\\n    checkKey(key);\\n    checkDescriptor(newDescriptor);\\n\\n    let hasSaga = Reflect.has(store.injectedSagas, key);\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      const oldDescriptor = store.injectedSagas[key];\\n      // enable hot reloading of daemon and once-till-unmount sagas\\n      if (hasSaga && oldDescriptor.saga !== saga) {\\n        oldDescriptor.task.cancel();\\n        hasSaga = false;\\n      }\\n    }\\n\\n    if (\\n      !hasSaga ||\\n      (hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT)\\n    ) {\\n      /* eslint-disable no-param-reassign */\\n      store.injectedSagas[key] = {\\n        ...newDescriptor,\\n        task: store.runSaga(saga, args),\\n      };\\n      /* eslint-enable no-param-reassign */\\n    }\\n  };\\n}\\n\\nexport function ejectSagaFactory(store, isValid) {\\n  return function ejectSaga(key) {\\n    if (!isValid) checkStore(store);\\n\\n    checkKey(key);\\n\\n    if (Reflect.has(store.injectedSagas, key)) {\\n      const descriptor = store.injectedSagas[key];\\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\\n        descriptor.task.cancel();\\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\\n        if (process.env.NODE_ENV === 'production') {\\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\\n        }\\n      }\\n    }\\n  };\\n}\\n\\nexport default function getInjectors(store) {\\n  checkStore(store);\\n\\n  return {\\n    injectSaga: injectSagaFactory(store, true),\\n    ejectSaga: ejectSagaFactory(store, true),\\n  };\\n}\\n\",\"import React from 'react';\\nimport hoistNonReactStatics from 'hoist-non-react-statics';\\nimport { ReactReduxContext } from 'react-redux';\\n\\nimport getInjectors from './sagaInjectors';\\n\\n/**\\n * Dynamically injects a saga, passes component's props as saga arguments\\n *\\n * @param {string} key A key of the saga\\n * @param {function} saga A root saga that will be injected\\n * @param {string} [mode] By default (constants.DAEMON) the saga will be started\\n * on component mount and never canceled or started again. Another two options:\\n *   - constants.RESTART_ON_REMOUNT — the saga will be started on component mount and\\n *   cancelled with `task.cancel()` on component unmount for improved performance,\\n *   - constants.ONCE_TILL_UNMOUNT — behaves like 'RESTART_ON_REMOUNT' but never runs it again.\\n *\\n */\\nexport default ({ key, saga, mode }) => WrappedComponent => {\\n  class InjectSaga extends React.Component {\\n    static WrappedComponent = WrappedComponent;\\n\\n    static contextType = ReactReduxContext;\\n\\n    static displayName = `withSaga(${WrappedComponent.displayName ||\\n      WrappedComponent.name ||\\n      'Component'})`;\\n\\n    constructor(props, context) {\\n      super(props, context);\\n\\n      this.injectors = getInjectors(context.store);\\n\\n      this.injectors.injectSaga(key, { saga, mode }, this.props);\\n    }\\n\\n    componentWillUnmount() {\\n      this.injectors.ejectSaga(key);\\n    }\\n\\n    render() {\\n      return <WrappedComponent {...this.props} />;\\n    }\\n  }\\n\\n  return hoistNonReactStatics(InjectSaga, WrappedComponent);\\n};\\n\\nconst useInjectSaga = ({ key, saga, mode }) => {\\n  const context = React.useContext(ReactReduxContext);\\n  React.useEffect(() => {\\n    const injectors = getInjectors(context.store);\\n    injectors.injectSaga(key, { saga, mode });\\n\\n    return () => {\\n      injectors.ejectSaga(key);\\n    };\\n  }, []);\\n};\\n\\nexport { useInjectSaga };\\n\",\"import { conformsTo, isFunction, isObject } from 'lodash';\\nimport invariant from 'invariant';\\n\\n/**\\n * Validate the shape of redux store\\n */\\nexport default function checkStore(store) {\\n  const shape = {\\n    dispatch: isFunction,\\n    subscribe: isFunction,\\n    getState: isFunction,\\n    replaceReducer: isFunction,\\n    runSaga: isFunction,\\n    injectedReducers: isObject,\\n    injectedSagas: isObject,\\n  };\\n  invariant(\\n    conformsTo(store, shape),\\n    '(app/utils...) injectors: Expected a valid redux store',\\n  );\\n}\\n\",\"import invariant from 'invariant';\\nimport { isEmpty, isFunction, isString } from 'lodash';\\n\\nimport checkStore from './checkStore';\\nimport createReducer from '../reducers';\\n\\nexport function injectReducerFactory(store, isValid) {\\n  return function injectReducer(key, reducer) {\\n    if (!isValid) checkStore(store);\\n\\n    invariant(\\n      isString(key) && !isEmpty(key) && isFunction(reducer),\\n      '(app/utils...) injectReducer: Expected `reducer` to be a reducer function',\\n    );\\n\\n    // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\\n    if (\\n      Reflect.has(store.injectedReducers, key) &&\\n      store.injectedReducers[key] === reducer\\n    )\\n      return;\\n\\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\\n    store.replaceReducer(createReducer(store.injectedReducers));\\n  };\\n}\\n\\nexport default function getInjectors(store) {\\n  checkStore(store);\\n\\n  return {\\n    injectReducer: injectReducerFactory(store, true),\\n  };\\n}\\n\",\"import React from 'react';\\nimport hoistNonReactStatics from 'hoist-non-react-statics';\\nimport { ReactReduxContext } from 'react-redux';\\n\\nimport getInjectors from './reducerInjectors';\\n\\n/**\\n * Dynamically injects a reducer\\n *\\n * @param {string} key A key of the reducer\\n * @param {function} reducer A reducer that will be injected\\n *\\n */\\nexport default ({ key, reducer }) => WrappedComponent => {\\n  class ReducerInjector extends React.Component {\\n    static WrappedComponent = WrappedComponent;\\n\\n    static contextType = ReactReduxContext;\\n\\n    static displayName = `withReducer(${WrappedComponent.displayName ||\\n      WrappedComponent.name ||\\n      'Component'})`;\\n\\n    constructor(props, context) {\\n      super(props, context);\\n\\n      getInjectors(context.store).injectReducer(key, reducer);\\n    }\\n\\n    render() {\\n      return <WrappedComponent {...this.props} />;\\n    }\\n  }\\n\\n  return hoistNonReactStatics(ReducerInjector, WrappedComponent);\\n};\\n\\nconst useInjectReducer = ({ key, reducer }) => {\\n  const context = React.useContext(ReactReduxContext);\\n  React.useEffect(() => {\\n    getInjectors(context.store).injectReducer(key, reducer);\\n  }, []);\\n};\\n\\nexport { useInjectReducer };\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{adc20f99e57c573c589c:function(e,c,n){\"use strict\";var t=n(\"8af190b70a6bc55c6f1b\"),a=n.n(t),r=(n(\"5ef9de3df8d92ea0e41c\"),n(\"d7dd51e1bf6bfc2c9c3d\")),f=n(\"f2873ecf7390fe7d7c89\"),d=n.n(f),u=n(\"5fa3f8487e09c6182715\"),i=n.n(u),o=n(\"f3b0ff1628e56352bcbf\"),s=n.n(o),b=n(\"a1cf5d6fa4ed65a6ddd5\"),j=n.n(b),g=n(\"6a4f9c383785f9168266\"),l=n.n(g),p=n(\"cc13decd9f9c09598c2f\"),v=\"@@saga-injector/daemon\",R=\"@@saga-injector/once-till-unmount\";function S(e){for(var c=1;c<arguments.length;c++){var n=null!=arguments[c]?arguments[c]:{},t=Object.keys(n);\"function\"===typeof Object.getOwnPropertySymbols&&(t=t.concat(Object.getOwnPropertySymbols(n).filter(function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.forEach(function(c){m(e,c,n[c])})}return e}function m(e,c,n){return c in e?Object.defineProperty(e,c,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[c]=n,e}var O=[\"@@saga-injector/restart-on-remount\",v,R],y=function(e){return l()(i()(e)&&!j()(e),\"(app/utils...) injectSaga: Expected `key` to be a non empty string\")},x=function(e){var c={saga:s.a,mode:function(e){return i()(e)&&O.includes(e)}};l()(d()(e,c),\"(app/utils...) injectSaga: Expected a valid saga descriptor\")};function w(e,c){return function(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2?arguments[2]:void 0;c||Object(p.a)(e);var r=S({},t,{mode:t.mode||v}),f=r.saga,d=r.mode;y(n),x(r);var u=Reflect.has(e.injectedSagas,n);(!u||u&&d!==v&&d!==R)&&(e.injectedSagas[n]=S({},r,{task:e.runSaga(f,a)}))}}function h(e,c){return function(n){if(c||Object(p.a)(e),y(n),Reflect.has(e.injectedSagas,n)){var t=e.injectedSagas[n];t.mode&&t.mode!==v&&(t.task.cancel(),e.injectedSagas[n]=\"done\")}}}function k(e){return Object(p.a)(e),{injectSaga:w(e,!0),ejectSaga:h(e,!0)}}n.d(c,\"a\",function(){return E});var E=function(e){var c=e.key,n=e.saga,t=e.mode,f=a.a.useContext(r.ReactReduxContext);a.a.useEffect(function(){var e=k(f.store);return e.injectSaga(c,{saga:n,mode:t}),function(){e.ejectSaga(c)}},[])}},cc13decd9f9c09598c2f:function(e,c,n){\"use strict\";n.d(c,\"a\",function(){return s});var t=n(\"d3a850c4000d77bccc89\"),a=n.n(t),r=n(\"f3b0ff1628e56352bcbf\"),f=n.n(r),d=n(\"f2873ecf7390fe7d7c89\"),u=n.n(d),i=n(\"6a4f9c383785f9168266\"),o=n.n(i);function s(e){var c={dispatch:f.a,subscribe:f.a,getState:f.a,replaceReducer:f.a,runSaga:f.a,injectedReducers:a.a,injectedSagas:a.a};o()(u()(e,c),\"(app/utils...) injectors: Expected a valid redux store\")}},d95b0cf107403b178365:function(e,c,n){\"use strict\";var t=n(\"8af190b70a6bc55c6f1b\"),a=n.n(t),r=(n(\"5ef9de3df8d92ea0e41c\"),n(\"d7dd51e1bf6bfc2c9c3d\")),f=n(\"5fa3f8487e09c6182715\"),d=n.n(f),u=n(\"f3b0ff1628e56352bcbf\"),i=n.n(u),o=n(\"a1cf5d6fa4ed65a6ddd5\"),s=n.n(o),b=n(\"6a4f9c383785f9168266\"),j=n.n(b),g=n(\"cc13decd9f9c09598c2f\"),l=n(\"491cc2e27aa2b4221847\");function p(e,c){return function(n,t){c||Object(g.a)(e),j()(d()(n)&&!s()(n)&&i()(t),\"(app/utils...) injectReducer: Expected `reducer` to be a reducer function\"),Reflect.has(e.injectedReducers,n)&&e.injectedReducers[n]===t||(e.injectedReducers[n]=t,e.replaceReducer(Object(l.a)(e.injectedReducers)))}}function v(e){return Object(g.a)(e),{injectReducer:p(e,!0)}}n.d(c,\"a\",function(){return R});var R=function(e){var c=e.key,n=e.reducer,t=a.a.useContext(r.ReactReduxContext);a.a.useEffect(function(){v(t.store).injectReducer(c,n)},[])}}}]);","extractedComments":[]}